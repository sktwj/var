.global _start
_start:

//1 cpu内部通用寄存器的赋值操作
mov r0, #100 //r0 = 100
mov r0, r1 //r0 = r1
mvn r0, #0xff //r0 = ~0xff

//arm cpu是RISC精简指令集，指令总数少，并且每条指令都是和cpu字长相等，32位cpu每条指令都是32位，其中一些指令需要传递常量数字，指令中只有12位来表示数字
//12位数字表示法采用8和4的组合,由8位有效位和4位移位数来表示一个数字

//2 非法立即数的赋值，伪指令ldr，cpu本身无法识别，该指令在编译时将由编译器转换成cpu可以识别的指令
ldr r0, =0x123456 //r0 = 0x123456

//3 访存操作，通过地址访问cpu外部资源
ldr r0, [r1] //r0 = *r1
str r0, [r1] //*r1 = r0

//原指令访问地址内容时采用是cpu字长的长度，我们也可以使用更精确的位长来访问，比如ldrb, strb, 采用8位方式访问地址内容

//以下扩展格式是ldr和str都可以使用的
ldr r0, [r1], #4 //r0 = *r1; r1 += 4
ldr r0, [r1, #4] //r0 = *(r1 + 4)
ldr r0, [r1, #-4]! //r0 = *(r1 - 4); r1 -= 4

//4 运算操作，以下指令的语法格式都是通用的
and r0, r1 //r0 &= r1
orr r0, #0x100 //r0 |= 0x100
add r0, r1, #0x200 //r0 = r1 + 0x200
sub r0, r1, r2 //r0 = r1 - r2
bic r0, #0xff //r0 &= ~0xff

//5 无限循环
loop:
	b loop

//6 PC寄存器（R15） process counter
//读取时得到当前正在执行的指令的内存地址+8
//对pc寄存器赋值，将造成指令跳转，写入时不需要加偏移量

//7 LR寄存器(R14): linker register
//专门用于保存函数的返回地址的, bl指令会自动对lr赋值