#include "head.h"

//使用库文件的主要原因是：很多功能比较完备，而且被频繁使用的函数，没有必要在每次使用时都重新编写。复用已经存在的库文件中的函数即可，这也避免了重复造轮子的行为。
//库文件分为：静态库和共享库（相当于windows中的动态库.dll）
//库文件都是由目标文件制作而成的。
//制作静态库：ar -crv lib指定的静态库文件.a 需要制作成静态库的目标文件

//制作共享库：
//1、 gcc -fPIC -c 需要制作成共享库文件的源文件
//	其中 PIC 表示：position independent code 位置无关的代码
//2、 gcc -shared -o lib指定的共享库文件名.so 需要制作成共享库的目标文件
//也可以将上面2步合成一步来制作：gcc -shared -fPIC -o lib指定的共享库文件名.so 需要制作成共享库文件的源文件

//制作完成之后，进行链接：gcc main函数所在的源文件 共享库文件 
//生成了可执行文件后，可以试这着执行：./a.out
//上一步一般都会出错，是因为gcc编译器只会到用gcc -print-search-dirs中查看的目录下去查找需要链接的库文件，否则会视而不见。
//解决方案1：将库文件拷贝到/usr/lib或/lib目录
//		也或者在/usr/lib或/lib目录下建立一个该库文件的软链接文件
//解决方案2：将制作的库文件所在的目录添加到LD_LIBRARY_PATH这个环境变量中：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd` 
//解决方案3：将当前制作的库文件所在的目录追加到/etc/ld.so.conf文件中（该文件必须存在，且超级用户才能执行）： pwd >> /etc/ld.so.conf  之后还需要用ldconfig命令更新该文件

//通常来说，对于一个工程，头文件不会和源文件在同一个目录下，库文件也不会和源文件在同一个目录下，那么此时在链接时，需要按照下面的方式进行链接：
//gcc main函数所在的源文件 -I头文件所在的目录 -L库文件所在的目录 -l自己指定的库文件名 
//而且该方式优先链接的是共享库，如果需要指定链接的是静态库，需要这么做：gcc -static main函数所在的源文件 -I头文件所在的目录 -L库文件所在的目录 -l自己指定的库文件名

//在链接生成最终的可执行文件后，可以使用"ldd 可执行文件"来模拟执行一次，这样就可以知道是否所有需要链接的库文件都已经被找到了。

//静态库和共享库的区别：
//静态库：在编译时所有需要使用的函数已经被编译进可执行文件中了，所以在生成最终的可执行文件之后，库文件就没有存在的必要了。
//共享库：在编译时，仅仅是简单的记录下需要使用的函数，并没有将使用的这些函数编译进可执行文件，可执行文件中仅仅是对这些函数符号进行简单的引用，所以最终生成的可执行文件体积相对静态库文件生成的可执行文件要小。生成了可执行文件后，是在运行时，动态的加载位于内存中的函数，所以该函数所在文件在被制作为共享库时，必须是位置无关的，只有在程序运行过程中才能真正确定下来该函数的地址。所以可以实现代码段的共享，但不共享数据段。而静态库是通过代码拷贝的方式来实现链接的，所以无法共享同一个代码段。通常我们应用程序的升级就是通过升级共享库来实现的。

int main(void)
{
	get_time();
	luck("everyone");
	return 0;
}
