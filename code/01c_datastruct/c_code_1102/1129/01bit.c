#include <stdio.h>

//位操作：针对的是二进制整型数
//数的表现形式常见的有：十进制，八进制，十六进制，二进制 ...
//数的表现形式和实际的存储方式无关，在内存中数据都是按照二进制形式存放的

//数据分为有符号数和无符号数：
//无符号数：没有符号位，所有位都表示数据的有效部分
//有符号数：数据的最高位是符号位，为0表示非负数，为1表示负数

//在C中，int类型如果没有任何限定，通常表示有符号int类型，如果想表示无符号的，需要用unsigned限定

#if 0
//位操作的运算符：
	& 按位与：左右操作数对应位均为1，结果该位为1，否则为0

	| 按位或：左右操作数对应位只要有一个为1，结果该位为1，否则为0

	^ 按位异或：左右操作数对应位不同，结果该位为1，相同则为0

	~ 按位取反：一元运算符，操作数每一位0变1，1变0

	<< 按位左移：左操作数移出去右操作数指定的位数，移出去的位丢弃，右边移进来的是0

	>> 按位右移：
		如果是无符号数或者有符号非负数，右移进来的是0，右移出去的丢弃
		如果是有符号负数，是未定义的（因不同平台的具体实现而异，某些平台移入符号位(通常称为算术右移)，某些平台移入0(通常称为逻辑右移)）

	//如果对于移植性有要求，请指针对无符号数进行右移操作

#endif

int main(void)
{
	//不因平台而异，要表示一个全1的数据
	unsigned int a = ~0;

	//不因平台而异，需要一个数据除最低5位为0外，其他位均为1
	a = ~0x1f;

	//将一个数据的第4位清0 （&通常用于清0）
	a = 0x14;
	a &= ~(1 << 4);
	printf("and, a = %#x\n", a);

	//将一个数据的第4位置1 （|通常用于置1）
	a |= 1 << 4;
	printf("or, a = %#x\n", a);

	//不用第三个变量，交换两个变量的值
	void _swap(int *a, int *b) //该方法，在*a+*b已经超出了int能够表示的最大范围时，结果是无法保证正确的。
	{
		*a = *a + *b; //7
		*b = *a - *b; //7-4 = 3;
		*a = *a - *b; //7-3 = 4
	}

	void swap(int *a, int *b)
	{
		*a ^= *b;
		*b ^= *a;
		*a ^= *b;
	}

	int m = 3, n = 4;
	swap(&m, &n);
	printf("m = %d, n = %d\n", m, n);

	//用宏和位操作实现大小端交换
	#define SWAP_ENDIAN(n) \
		(n << 24) | \
		(n >> 8 << 24 >> 8) | \
		(n << 8 >> 24 << 8) | \
		(n >> 24)

	#define _SWAP_ENDIAN(n) \
		((n & 0xff) << 24) | \
		((n & 0xff00) << 8) | \
		((n & 0xff0000) >> 8) | \
		(n >> 24)

	#define __swap_endian(n) \
		((n & 0xff) << 24) | \
		(((n >> 8) & 0xff) << 16) | \
		(((n >> 16) & 0xff) << 8) | \
		(n >> 24)

	size_t abc = 0x12345678;
	//abc = _SWAP_ENDIAN(abc);
	abc = __swap_endian(abc);
	printf("abc = %#x\n", abc);

	//判断一个数是否2的幂
	int is_2_power(size_t n) 
	{
		if (n == 0) {
			return 0;
		}

		return !(n & (n-1));
	}

	int num = 6;
	printf("%d %s是\n", 
			num, is_2_power(num) ? "" : "不");

	return 0;
}
