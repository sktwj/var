#include <stdio.h>

int main(void)
{
	int *p; //野指针，指向的内存空间不可知
	printf("*p = %d\n", *p);

	int a = 10;
	p = &a;
	printf("*p = %d\n", *p);

	int *q = NULL; //空指针，NULL是因系统系统而异的一个宏常量，因不同系统的实现而异，某些系统是(void*)0, 某些系统甚至可能是可以被访问的0地址，或者一个确定的可访问的内存地址
	//在linux系统中，他的值是0，但他并不表示一个内存中的任何一个地址，仅仅是一个一旦访问就段错误的符号常量

	//在确切知道指针应该指向某个变量之前，都应该将指针置为NULL
	q = &a;
	printf("*q = %d\n", *q);

	//void 不可能出现在类型声明中，因为编译器无法获得该为此类型的变量分配字节数的信息，所以无法通过编译
	//void v; //error
	void *pv; //通用类型的指针变量
	pv = &a;
	printf("*pv = %d\n", *((int *)pv));
	//printf("size *pv = %d\n", sizeof(*pv)); //通用类型的指针最早是char*，而非void*，虽然无法确定pv指向的变量所占据的内存的字节数，但依然保留了原始的1字节 

	q = (int *)pv; //在C中可以无须强转编译通过，但C++中必须强制类型转换
	pv = q;
	printf("%d\n", *((int*)pv));

	// (type) 被称为强制类型转换符，type表示你想要转换成的类型
	//与之对应的另一套转换被称为隐式(implicit)类型转换
	//会进行隐式类型转换的情况：
	//1、当函数的返回值的类型和实际return语句返回的值的类型不同时，会将return返回值的类型向函数返回值的类型转换
	//2、当函数调用时，实参和形参的类型不同时，会将实际参数按照形式参数的类型进行转换
	//3、在参数运算的表达式中出现不同类型的变量时，详细规则见C_primer plus书5.5节：类型转换

	return 0;
}
